<!DOCTYPE html><html lang="en"><head><title>adt/lazy_binomial_queue</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="adt/lazy_binomial_queue"><meta name="groc-project-path" content="js/src/adt/lazy_binomial_queue.js"><meta name="groc-github-url" content="https://github.com/aureooms/js-algo"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/aureooms/js-algo/blob/master/js/src/adt/lazy_binomial_queue.js">js/src/adt/lazy_binomial_queue.js</a></div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> lazy_binomial_queue_t = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(pred, opt_t)</span>{</span>

	<span class="hljs-keyword">var</span> binomial_tree_t = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value, next)</span>{</span>
		<span class="hljs-keyword">this</span>.value = value;
		<span class="hljs-keyword">this</span>.next = next;
	};


	binomial_tree_t.prototype.rank = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.next.length;
	};


	<span class="hljs-keyword">var</span> lazy_binomial_queue = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
		<span class="hljs-keyword">this</span>.length = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">this</span>.list = [<span class="hljs-literal">null</span>];
		<span class="hljs-keyword">this</span>.lazy = [];
	};



	<span class="hljs-keyword">var</span> binomial_tree_merge = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(tree1, tree2)</span>{</span>
		<span class="hljs-keyword">var</span> value = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">var</span> next = <span class="hljs-literal">null</span>;

		<span class="hljs-keyword">if</span>(pred(tree1.value, tree2.value)){
			value = tree1.value;
			next = tree1.next.concat(tree2);
		}
		<span class="hljs-keyword">else</span>{
			value = tree2.value;
			next = tree2.next.concat(tree1);
		}

		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> binomial_tree_t(value, next);
	};


	<span class="hljs-keyword">var</span> lazy_binomial_queue_push = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(queue, value)</span>{</span>
		<span class="hljs-keyword">var</span> tree = <span class="hljs-keyword">new</span> binomial_tree_t(value, []);
		queue.lazy.push([tree]);
		++queue.length;
	};

	<span class="hljs-keyword">var</span> max = opt_t(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span>{</span> <span class="hljs-keyword">return</span> a.rank() &gt; b.rank(); });

	<span class="hljs-keyword">var</span> lazy_binomial_queue_merge = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(queue, tree_l)</span>{</span>
		<span class="hljs-keyword">if</span>(tree_l.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;

		<span class="hljs-keyword">var</span> r = <span class="hljs-literal">null</span>;

		<span class="hljs-keyword">var</span> m = max(tree_l);
		<span class="hljs-keyword">while</span>(queue.list.length &lt; m.rank() + <span class="hljs-number">2</span>) queue.list.push(<span class="hljs-literal">null</span>);

		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; tree_l.length; ++i){
			<span class="hljs-keyword">var</span> j = tree_l[i].rank();

			<span class="hljs-keyword">if</span>(r === <span class="hljs-literal">null</span>){
				<span class="hljs-keyword">if</span>(queue.list[j] === <span class="hljs-literal">null</span>) queue.list[j] = tree_l[i];
				<span class="hljs-keyword">else</span>{
					r = binomial_tree_merge(tree_l[i], queue.list[j]);
					queue.list[j] = <span class="hljs-literal">null</span>;
				}
			}
			<span class="hljs-keyword">else</span>{
				r = binomial_tree_merge(tree_l[i], r);
			}

			<span class="hljs-keyword">if</span>(i === tree_l.length - <span class="hljs-number">1</span> || tree_l[i+<span class="hljs-number">1</span>].rank() !== j + <span class="hljs-number">1</span>){
				<span class="hljs-keyword">var</span> k = j + <span class="hljs-number">1</span>;
				<span class="hljs-keyword">while</span>(r !== <span class="hljs-literal">null</span> &amp;&amp; (i === tree_l.length - <span class="hljs-number">1</span> || tree_l[i+<span class="hljs-number">1</span>].rank() !== k)){
					<span class="hljs-keyword">if</span>(queue.list[j+<span class="hljs-number">1</span>] === <span class="hljs-literal">null</span>){
						queue.list[j+<span class="hljs-number">1</span>] = r;
						r = <span class="hljs-literal">null</span>;
					}
					<span class="hljs-keyword">else</span>{
						r = binomial_tree_merge(queue.list[j+<span class="hljs-number">1</span>], r);
						queue.list[j+<span class="hljs-number">1</span>] = <span class="hljs-literal">null</span>;
					}

					++k;
				}

			}

		}

		<span class="hljs-keyword">if</span>(queue.list[queue.list.length - <span class="hljs-number">1</span>] !== <span class="hljs-literal">null</span>) queue.list.push(<span class="hljs-literal">null</span>);

	};


	<span class="hljs-keyword">var</span> lazy_binomial_queue_pop = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(queue)</span>{</span>
		<span class="hljs-keyword">var</span> value = -<span class="hljs-number">1</span>, x = -<span class="hljs-number">1</span>, i;

		<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; queue.lazy.length; ++i){
			<span class="hljs-keyword">var</span> tree_l = queue.lazy[i];
			lazy_binomial_queue_merge(queue, tree_l);
		}

		<span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; queue.list.length - <span class="hljs-number">1</span>; ++i){
			<span class="hljs-keyword">if</span>(queue.list[i] !== <span class="hljs-literal">null</span>){
				x = i;
				value = queue.list[x].value;
				<span class="hljs-keyword">break</span>;
			}
		}

		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = x + <span class="hljs-number">1</span>; j &lt; queue.list.length - <span class="hljs-number">1</span>; ++j){
			<span class="hljs-keyword">if</span>(queue.list[j] !== <span class="hljs-literal">null</span> &amp;&amp; pred(queue.list[j].value, value)){
				x = j;
				value = queue.list[x].value;
			}
		}

		value = queue.list[x].value;
		queue.lazy = [queue.list[x].next];
		queue.list[x] = <span class="hljs-literal">null</span>;

		<span class="hljs-keyword">if</span>(i === queue.list.length - <span class="hljs-number">2</span>) queue.list.pop();

		--queue.length;

		<span class="hljs-keyword">return</span> value;
	};

	lazy_binomial_queue.prototype.pop = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
		<span class="hljs-keyword">return</span> lazy_binomial_queue_pop(<span class="hljs-keyword">this</span>);
	};

	lazy_binomial_queue.prototype.push = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span>{</span>
		<span class="hljs-keyword">return</span> lazy_binomial_queue_push(<span class="hljs-keyword">this</span>, value);
	};

	<span class="hljs-keyword">return</span> lazy_binomial_queue;
};

exports.lazy_binomial_queue_t = lazy_binomial_queue_t;</div></div></div></div></body></html>